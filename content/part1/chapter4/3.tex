We are going to start with RTTI replacement in the LLVM code and discuss how it's implemented. We will then continue with basic containers and smart pointers. We will conclude with some important classes used to represent token locations and how diagnostics are realized in Clang. Later, in Section 4.6, Clang plugin project, we will use some of these classes in our test project.

\mySubsubsection{4.3.1.}{RTTI replacement and cast operators}

As mentioned earlier, LLVM avoids using RTTI due to performance concerns. LLVM has introduced several helper functions that replace RTTI counterparts, allowing for the casting of an object from one type to another. The fundamental ones are as follows:

\begin{itemize}
\item
llvm::isa<> is akin to Java's javainstanceof operator. It returns true or false depending on whether the reference to the tested object belongs to the tested class or not.

\item
llvm::cast<>: Use this cast operator when you're certain that the object is of the specified derived type. If the cast fails (i.e., the object isn't of the expected type), llvm::cast will abort the program. Use it only when you're confident the cast won't fail.

\item
llvm::dyn\_cast<>: This is perhaps the most frequently used casting operator in LLVM. llvm::dyn\_cast is employed for safe downcasting when you anticipate the cast will usually succeed, but there's some uncertainty. If the object isn't of the specified derived type, llvm::dyn\_cast<> returns nullptr.
\end{itemize}

The cast operators do not accept nullptr as input. However, there are two special cast operators that can handle null pointers:

\begin{itemize}
\item
llvm::cast\_if\_present<>: A variant of llvm::cast<> that accepts nullptr values

\item
llvm::dyn\_cast\_if\_present<>: A variant of llvm::dyn\_cast<> that accepts nullptr values
\end{itemize}

Both operators can handle nullptr values. If the input is nullptr or if the cast fails, they simply return nullptr.

\begin{myNotic}{Important note}
It's worth noting that the casting operators llvm::cast\_if\_present<> and llvm: :dyn\_cast\_if\_present<> were introduced recently, specifically in 2022. They serve as replacements for popular ones llvm::cast\_or\_null<> and llvm::dyn\_cast\_or \_null<>, which had been in recent use. The older versions are still supported and now redirect calls to the newer cast operators. For more information, see the discussion about this change: \url{https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018}
\end{myNotic}

The following question might arise: how can the dynamic cast operation be performed without RTTI? This can be achieved with certain specific decorations, as illustrated in a simple example inspired by How to set up LLVM-style RTTI for your class hierarchy \footnote{LLVM Community. How to set up LLVM-style RTTI for your class hierarchy. 2023. URL \url{https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html}.}. We'll begin with a base class, clangbook::Animal, that has two descendants: clangbook::Horse and clangbook::Sheep. Each horse can be categorized by its speed (in mph), and each sheep by its wool mass. Here's how it can be used:

\begin{cpp}
void testAnimal() {
  auto AnimalPtr = std::make_unique<clangbook::Horse>(10);
  if (llvm::isa<clangbook::Horse>(AnimalPtr)) {
    llvm::outs()
      << "Animal is a Horse and the horse speed is: "
      << llvm::dyn_cast<clangbook::Horse>(AnimalPtr.get())->getSpeed()
      << "mph \n";
  } else {
    llvm::outs() << "Animal is not a Horse\n";
  }
}
\end{cpp}

\begin{center}
Figure 4.2: LLVM isa<> and dyn\_cast<> usage example
\end{center}

The code should produce the following output:

\begin{shell}
Animal is a Horse and the horse speed is: 10mph
\end{shell}

Line 48 in Figure 4.2 demonstrates the use of llvm::isa<>, while Line 51 showcases llvm::dyn\_cast<>. In the latter, we cast the base class to clangbook::Horse and call a method specific to that class.

Let's look into the class implementations, which will provide insights into how the RTTI replacement works. We will start with the base class clangbook::Animal:

\begin{cpp}
class Animal {
public:
  enum AnimalKind { AK_Horse, AK_Sheep };

public:
  Animal(AnimalKind K) : Kind(K){};
  AnimalKind getKind() const { return Kind; }

private:
  const AnimalKind Kind;
};
\end{cpp}

\begin{center}
Figure 4.3: clangbook::Animal class
\end{center}

The most crucial aspect is Line 11 in the preceding code. It specifies different "kinds" of animals. One enum value is used for the horse (AK\_Horse) and another for the sheep (AK\_Sheep). Hence, the base class has some knowledge about its descendants. The implementations for the clangbook::Horse and clangbook::Sheep classes can be found in the following code:

\begin{cpp}
class Horse : public Animal {
public:
  Horse(int S) : Animal(AK_Horse), Speed(S){};

  static bool classof(const Animal *A) { return A->getKind() == AK_Horse; }

  int getSpeed() { return Speed; }

private:
  int Speed;
};

class Sheep : public Animal {
public:
  Sheep(int WM) : Animal(AK_Sheep), WoolMass(WM){};

  static bool classof(const Animal *A) { return A->getKind() == AK_Sheep; }

  int getWoolMass() { return WoolMass; }

private:
  int WoolMass;
};
\end{cpp}

\begin{center}
Figure 4.4: clangbook::Horse and clangbook::Sheep classes
\end{center}

Lines 25 and 37 are particularly important as they contain the classof static method implementation. This method is crucial for the cast operators in LLVM. A typical implementation might look like the following (simplified version):

\begin{cpp}
template <typename To, typename From>
bool isa(const From *Val) {
  return To::classof(Val);
}
\end{cpp}

\begin{center}
Figure 4.5: Simplified implementation for llvm::isa<>
\end{center}

The same mechanism can be applied to other cast operators.

Our next topic will discuss various types of containers that serve as more powerful alternatives to their corresponding STL counterparts.

\mySubsubsection{4.3.2.}{Containers}

The LLVM ADT (which stands for Abstract Data Type) library offers a set of containers. While some of them are unique to LLVM, others can be considered as replacements for containers from the STL. We will explore some of the most popular classes provided by the ADT.

\mySamllsection{String operations}

The primary class for working with strings in the standard C++ library is std::string. Although this class was designed to be universal, it has some performance related issues. A significant issue concerns the copy operation. Since copying strings is a common operation in compilers, LLVM introduced a specialized class, llvm::StringRef, that handles this operation efficiently without using extra memory. This class is comparable to std::string\_view from C++17 \footnote{International Organization for Standardization. International Standard ISO/IEC 14882:2017(E) – Programming Languages – C++. International Organization for Standardization, 2017. URL \url{https://www.iso.org/standard/69466.html}.} and std::span from C++20 \footnote{International Organization for Standardization. International Standard ISO/IEC 14882:2020(E) – Programming Languages – C++. International Organization for Standardization, 2020. URL \url{https://www.iso.org/standard/73560.html}.}.

The llvm::StringRef class maintains a reference to data, which doesn't need to be null-terminated like traditional C/C++ strings. It essentially holds a pointer to a data block and the block's size, making the object's effective size 16 bytes. Because llvm::StringRef retains a reference rather than the actual data, it must be constructed from an existing data source. This class can be instantiated from basic string objects such as const char*, std::string, and std::string\_view. The default constructor creates an empty object. Typical usage example for llvm::StringRef is shown in Figure 4.6:

\begin{cpp}
#include "llvm/ADT/StringRef.h"
...
llvm::StringRef StrRef("Hello, LLVM!");
// Efficient substring, no allocations
llvm::StringRef SubStr = StrRef.substr(0, 5);

llvm::outs() << "Original StringRef: " << StrRef.str() << "\n";
llvm::outs() << "Substring: " << SubStr.str() << "\n";
\end{cpp}

\begin{center}
Figure 4.6: llvm::StringRef usage example
\end{center}

The output for the code is shown here:

\begin{shell}
Original StringRef: Hello, LLVM!
Substring: Hello
\end{shell}

Another class used for string manipulation in LLVM is llvm::Twine, which is particularly useful when concatenating several objects into one. A typical usage example for the class is shown in Figure 4.7:

\begin{cpp}
#include "llvm/ADT/Twine.h"
...
llvm::StringRef Part1("Hello, ");
llvm::StringRef Part2("Twine!");
llvm::Twine Twine = Part1 + Part2;  // Efficient concatenation

// Convert twine to a string (actual allocation happens here)
std::string TwineStr = Twine.str();
llvm::outs() << "Twine result: " << TwineStr << "\n";
\end{cpp}

\begin{center}
Figure 4.7: llvm::Twine usage example
\end{center}

The output for the code is shown here:

\begin{shell}
Twine result: Hello, Twine!
\end{shell}

Another class that is widely used for string manipulations is llvm::SmallString<>. It represents a string that is stack-allocated up to a fixed size, but can also grow beyond this size, at which point it heap-allocates memory. This is a blend between the space efficiency of stack allocation and the flexibility of heap allocation.

The advantage of llvm::SmallString<> is that for many scenarios, especially in compiler tasks, strings tend to be small and fit within the stack-allocated space. This avoids the overhead of dynamic memory allocation. But in situations where a larger string is required, llvm::SmallString can still accommodate by transitioning to heap memory. A typical usage example is show in Figure 4.8:

\begin{cpp}
#include "llvm/ADT/SmallString.h"
...
// Stack allocate space for up to 20 characters.
llvm::SmallString<20> SmallStr;

// No heap allocation happens here.
SmallStr = "Hello, ";
SmallStr += "LLVM!";

llvm::outs() << "SmallString result: " << SmallStr << "\n";
\end{cpp}

\begin{center}
Figure 4.8: llvm::SmallString<> usage example
\end{center}

Despite the fact that string manipulation is key in compiler tasks such as text parsing, LLVM has many other helper classes. We'll explore its sequential containers next.

\mySamllsection{Sequential containers}

LLVM recommends some optimized replacements for arrays and vectors from the standard library. The most notable are:

\begin{itemize}
\item
llvm::ArrayRef<>: A helper class designed for interfaces that accept a sequential list of elements for read-only access. The class is akin to llvm::StringRef<> in that it does not own the underlying data but merely references it.

\item
llvm::SmallVector<>: An optimized vector for cases with a small size. It resembles llvm::SmallString, as discussed in Section 4.3.2, String operations. Notably, the size for the array isn't fixed, allowing the number of stored elements to grow. If the number of elements stays below N (the template argument), then there is no need for additional memory allocation.
\end{itemize}

Let's examine the llvm::SmallVector<> to better understand these containers, as shown in Figure 4.9:

\begin{cpp}
llvm::SmallVector<int, 10> SmallVector;
for (int i = 0; i < 10; i++) {
  SmallVector.push_back(i);
}
SmallVector.push_back(10);
\end{cpp}

\begin{center}
Figure 4.9: llvm::SmallVector<> usage
\end{center}

The vector is initialized at Line 1 with a chosen size of 10 (indicated by the second template argument). The container offers an API similar to std::vector<>, using the familiar push\_back method to add new elements, as seen in Figure 4.9, Lines 3 and 5.

The first 10 elements are added to the vector without any additional memory allocation (see Figure 4.9, Lines 2-4). However, when the eleventh element is added at Line 5, the array's size surpasses the pre-allocated space for 10 elements, triggering additional memory allocation. This container design efficiently minimizes memory allocation for small objects

while maintaining the flexibility to accommodate larger sizes when necessary.

\mySamllsection{Map-like containers}

The standard library provides several containers for storing key-value data. The most common ones are std::map<> for general-purpose maps and std::unordered\_map<> for hash maps. LLVM offers additional alternatives to these standard containers:

\begin{itemize}
\item
llvm::StringMap<>: A map that uses strings as keys. Typically, this is more performance optimized than the standard associative container, std::unordered\_map<std::string, T>. It is frequently used in situations where string keys are dominant and performance is critical, as one might expect in a compiler infrastructure like LLVM. Unlike many other data structures in LLVM, llvm::StringMap<> does not store a copy of the string key. Instead, it keeps a reference to the string data, so it's crucial to ensure the string data outlives the map to prevent undefined behavior.

\item
llvm::DenseMap<>: This map is designed to be more memory- and time-efficient than std::unordered\_map<> in most situations, though it comes with some additional constraints (e.g., keys and values having trivial destructors). It's especially beneficial when you have simple key-value types and require high-performance lookups.

\item
llvm::SmallDenseMap<>: This map is akin to llvm::DenseMap<> but is optimized for instances where the map size is typically small. It allocates from the stack for small maps and only resorts to heap allocation when the map exceeds a predefined size.

\item
llvm::MapVector<>: This container retains the insertion order, akin to Python's OrderedDict . It is implemented as a blend of std::vector and either llvm::DenseMap or llvm::SmallDenseMap.
\end{itemize}

It's noteworthy that these containers utilize a quadratically probed hash table mechanism. This method is effective for hash collision resolution because the cache isn't recomputed during element lookups. This is crucial for performance-critical applications, such as compilers.

\mySubsubsection{4.4.3.}{Smart pointers}

Different smart pointers can be found in LLVM code. The most popular ones come from the standard template library: std::unique\_ptr<> and std::shared\_ptr<>. In addition, LLVM provides some supplementary classes to work with smart pointers. One of the most prominent among them is llvm::IntrusiveRefCntPtr<>. This smart pointer is designed to work with objects that support intrusive reference counting. Unlike std::shared\_ptr, which maintains its own control block to manage the reference count, IntrusiveRefCntPtr expects the object to maintain its own reference count. This design can be more memory efficient. A typical usage example is shown here:

\begin{cpp}
class MyClass : public llvm::RefCountedBase<MyClass> {
  // ...
};

llvm::IntrusiveRefCntPtr<MyClass> Ptr = new MyClass();
\end{cpp}

\begin{center}
Figure 4.10: llvm::IntrusiveRefCntPtr<> usage example
\end{center}

As we can see, the smart pointer prominently employs the CRTP (which stands for Curiously Recurring Template Pattern) that was mentioned earlier in Section 3.3, AST traversal. The CRTP is essential for the Release operation when the reference count drops to 0 and the object must be deleted. The implementation is as follows:

\begin{cpp}
template <class Derived> class RefCountedBase {
  // ...
  void Release() const {
    assert(RefCount > 0 && "Reference count is already zero.");
    if (--RefCount == 0)
      delete static_cast<const Derived *>(this);
  }
}
\end{cpp}

\begin{center}
Figure 4.11: CRTP usage in llvm::RefCountedBase<>. The code was sourced from the llvm/ADT/IntrusiveRefCntPtr.h header
\end{center}

Since MyClass in Figure 4.10 is derived from RefCountedBase, we can perform a cast on it in Line 6 of Figure 4.11. This cast is feasible since the type to cast is known, given that it is provided as a template parameter.

We've just finished with LLVM basic libraries. Now it is time to move on to Clang basic libraries. Clang is a compiler frontend, and its most important operations are related to diagnostics. Diagnostics require precise information about position location in the source code. Let's explore the basic classes that Clang provides for these operations.


















































































