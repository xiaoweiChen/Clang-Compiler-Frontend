A CFG is the basic data structure for advanced static analysis using Clang tools. Clang constructs the CFG for a function from its AST, identifying basic blocks and control flow edges. Clang’s CFG construction handles various C/C++ constructs, including loops, conditional statements, switch cases, and complex constructs such as setjmp/longjmp and C++ exceptions. Let’s consider the process using our example from Figure 6.1.

6.5.1 CFG construction by example
Our example from Figure 6.1 has five nodes, as shown in Figure 6.2. Lets run a debugger to investigate the process, as follows:

\begin{shell}
$ lldb <...>/llvm-project/install/bin/clang-tidy --                   \
  -checks="-*,misc-cyclomaticcomplexity"                              \
  -config="{CheckOptions:                                             \
           [{key: misc-cyclomaticcomplexity.Threshold, value: ’1’}]}" \
  max.cpp                                                             \
  -- -std=c++17 -Wno-all
\end{shell}

\begin{center}
Figure 6.10: Debugger session running to investigate the CFG creation process
\end{center}

We used the same command as in Figure 6.8 but changed the first line of the command to run the check via a debugger. We also changed the last line to suppress all warnings from the compiler.

\begin{myNotic}{Important note}
Advanced static analysis is a part of semantic analysis. For example, warnings are printed if Clang detects unreachable code, controlled by the -Wunreachable-code option. The detector is a part of Clang’s semantic analysis and utilizes CFGs, in addition to ASTs, as the basic data structures to detect such issues. We can suppress these warnings and, as a result, disable CFG initialization in Clang by specifying the special -Wno-all command-line option, which suppresses all warnings generated by the compiler.
\end{myNotic}

We will set a breakpoint at the CFGBuilder::createBlock function, which creates a CFG block.

\begin{shell}
$ lldb <...>/llvm-project/install/bin/clang-tidy --                   \
  -checks="-*,misc-cyclomaticcomplexity"                              \
  -config="{CheckOptions:                                             \
           [{key: misc-cyclomaticcomplexity.Threshold, value: ’1’}]}" \
  max.cpp                                                             \
  -- -std=c++17 -Wno-all
...
(lldb) b CFGBuilder::createBlock
Breakpoint 1: where = ...CFGBuilder::createBlock(bool) const ...
\end{shell}

\begin{center}
Figure 6.11: Running debugger and setting breakpoint for CFGBuilder::createBlock
\end{center}

If we run the debugger, we will see that the function is called five times for our example; that is, five CFG blocks are created for our max function:

\begin{shell}
1  (lldb) r
2  ...
3     frame #0: ...CFGBuilder::createBlock...
4     1690 /// createBlock - Used to lazily create blocks that are connected
5     1691 ///  to the current (global) successor.
6     1692 CFGBlock *CFGBuilder::createBlock(bool add_successor) {
7  -> 1693   CFGBlock *B = cfg->createBlock();
8     1694   if (add_successor && Succ)
9     1695     addSuccessor(B, Succ);
10    1696   return B;
11
12 (lldb) c
13 ...
14 (lldb) c
15 ...
16 (lldb) c
17 ...
18 (lldb) c
19 ...
20 (lldb) c
21 ...
22 1  warning generated.
23 max.cpp:1:5: warning: function ’max’ has high cyclomatic complexity (2) [misc-cyclomaticcomplexity]
24 int max(int a, int b) {
25     ^
26 Process ... exited with status = 0 (0x00000000)
\end{shell}

\begin{center}
Figure 6.12: Creation of CFG blocks, with breakpoints highlighted
\end{center}

The debugger session shown in Figure 6.12 can be considered the entry point to the CFG creation process. Now, it’s time to delve deeply into the implementation details.

\mySubsubsection{6.5.2.}{CFG construction implementation details}

The blocks are created in reverse order, as seen in Figure 6.13. The first block to be created is the exit block, as shown in Figure 6.13, Line 4. Then, the CFG builder traverses the clang::Stmt object passed as a parameter (Line 9). The entry block is created last, at Line 12:

\begin{cpp}
std::unique_ptr<CFG> CFGBuilder::buildCFG(const Decl *D, Stmt *Statement) {
  ...
  // Create an empty block that will serve as the exit block for the CFG.
  Succ = createBlock();
  assert(Succ == &cfg->getExit());
  Block = nullptr;  // the EXIT block is empty.  ...
  ...
  // Visit the statements and create the CFG.
  CFGBlock *B = Visit(Statement, ...);
  ...
  // Create an empty entry block that has no predecessors.
  cfg->setEntry(createBlock());
  ...
  return std::move(cfg);
}
\end{cpp}

\begin{center}
Figure 6.13: Simplified buildCFG implementation from clang/lib/Analysis/CFG.cpp
\end{center}

The visitor uses the clang::Stmt::getStmtClass method to implement an ad hoc visitor based on the type of the statement, as shown in the following code snippet:

\begin{cpp}
CFGBlock *CFGBuilder::Visit(Stmt * S, ...) {
  ...
  switch (S->getStmtClass()) {
  ...
  case Stmt::CompoundStmtClass:
  return VisitCompoundStmt(cast<CompoundStmt>(S), ...);
  ...
  case Stmt::IfStmtClass:
  return VisitIfStmt(cast<IfStmt>(S));
  ...
  case Stmt::ReturnStmtClass:
  ...
  return VisitReturnStmt(S);
  ...
  }
}
\end{cpp}


\begin{center}
Figure 6.14: Statement visitor implementation; the cases used for our example are highlighted, the code was taken from clang/lib/Analysis/CFG.cpp
\end{center}

Our example includes two return statements and one if statement, which are combined into a compound statement. The relevant parts of the visitor are shown in Figure 6.14.

In our case, the passed statement is a compound statement; therefore, Line 6 from Figure 6.14 is activated. The following code is then executed:

\begin{cpp}
CFGBlock *CFGBuilder::VisitCompoundStmt(CompoundStmt *C, ...) {
  ...
  CFGBlock *LastBlock = Block;

  for (Stmt *S : llvm::reverse(C->body())) {
    // If we hit a segment of code just containing ’;’ (NullStmts), we can
    // get a null block back.  In such cases, just use the LastBlock
    CFGBlock *newBlock = Visit(S, ...);

    if (newBlock)
      LastBlock = newBlock;

    if (badCFG)
      return nullptr;
    ...
  }

  return LastBlock;
}
\end{cpp}


\begin{center}
Figure 6.15: Compound statement visitor, the code was taken from clang/lib/Analysis/CFG.cpp
\end{center}

Several constructions are visited while the CFG is being created for our example. The first one is clang::IfStmt. The relevant parts are shown in the following figure:

\begin{cpp}
CFGBlock *CFGBuilder::VisitIfStmt(IfStmt *I) {
  ...
  // Process the true branch.
  CFGBlock *ThenBlock;
  {
    Stmt *Then = I->getThen();
    ...
    ThenBlock = Visit(Then, ...);
    ...
  }

  // Specially handle "if (expr1 || ...)" and "if (expr1 && ...)"
  // ...
  if (Cond && Cond->isLogicalOp())
    ...
  else {
    // Now create a new block containing the if statement.
    Block = createBlock(false);
    ...
  }
  ...
}
\end{cpp}


\begin{center}
Figure 6.16: If statement visitor, the code was taken from clang/lib/Analysis/CFG.cpp
\end{center}

A special block for the if statement is created at Line 18. We also visit the ’then’ condition at Line 8.

The ’then’ condition leads to visiting a return statement. The corresponding code is as follows:

\begin{cpp}
CFGBlock *CFGBuilder::VisitReturnStmt(Stmt *S) {
  // Create the new block.
  Block = createBlock(false);
  ...
  // Visit children
  if (ReturnStmt *RS = dyn_cast<ReturnStmt>(S)) {
    if (Expr *O = RS->getRetValue())
      return Visit(O, ...);
    return Block;
  }
  ...
}
\end{cpp}

\begin{center}
Figure 6.17: Return statement visitor, the code was taken from clang/lib/Analysis/CFG.cpp
\end{center}

For our example, it creates a block at Line 3 and visits the return expression at Line 8. Our return expression is a trivial one that does not necessitate the creation of a new block.

The code fragments presented in Figure 6.13 to Figure 6.17 show only the block creation procedure. Some important parts were omitted for simplicity. Notably, the build procedure also involves the following:

\begin{itemize}
\item
Edge creation: A typical block can have one or more successors. The list of nodes (blocks) with a list of successors (edges) for each block maintains the entire graph structure, representing symbolic program execution.

\item
Storing meta-information: Each block stores additional meta-information associated with it. For instance, each block keeps a list of statements in the block.

\item
Processing edge cases: C++ is a complex language with many different language constructs that require special processing.
\end{itemize}

The CFG is a fundamental data structure for advanced code analysis. Clang has several tools created using CFGs. Let’s briefly look at them.

















