We will create a Clang tool that will help us to rename methods for a class that is used for unit testing. We will start with a description for the clang::Rewriter class â€“ the basic class that is used for code modifications.


\mySubsubsection{7.2.1.}{Code modification support at Clang}

clang::Rewriter is a Clang library class that facilitates source code rewriting operations within a translation unit. It provides methods for inserting, removing, and replacing code within theAbstract Syntax Tree (AST) of the source code. Developers can use clang::Rewriter for complex code modifications, such as restructuring or generating new code constructs. It can be applied for both code generation and code refactoring tasks, making it versatile for various code transformation purposes.

The class has several methods for text insertion; for instance, clang::Rewriter ::InsertText inserts the text at the specified source location, and clang ::SourceLocation is used to specify the exact location at the buffer, see Section 4.4.1, SourceManager and SourceLocation. In addition to the text insertion, you can also remove text with clang::Rewriter::RemoveText or replace text with a new one using clang::Rewriter::ReplaceText. The last two use source range (clang::SourceRange) to specify the positions at the text to be removed or replaced.

clang::Rewriter uses clang::SourceManager, as explained in Section 4.4.1, SourceManager and SourceLocation, to access the source code that needs to be modified. Let's look at how Rewriter can be used in a real project.

\mySubsubsection{7.2.2.}{Test class}

Suppose we have a class that is used for tests. The class name starts with the "Test" prefix (for instance, TestClass), but there aren't any 'test\_' prefixes for public methods of the class. For instance, the class has a public method with the name 'pos' (TestClass::pos) instead of 'test\_pos' (TestClass::test\_pos()). We want to create a tool that will add such a prefix for the class methods.

\begin{cpp}
class TestClass {
public:
  TestClass(){};
  void pos(){};

private:
  void private_pos(){};
};
\end{cpp}

Original code

\begin{cpp}
class TestClass {
public:
  TestClass(){};
  void test_pos(){};

private:
  void private_pos(){};
};
\end{cpp}

Modified code

\begin{center}
Figure 7.1: Code transformations for TestClass
\end{center}


Thus, we want the method TestClass::pos (see Figure 7.1) to be replaced with TestClass::test\_pos at the class declaration.

If we have a code where we make a call to the method, the following replacement should be made:

\begin{cpp}
TestClass test;
test.pos();
\end{cpp}

Original code

\begin{cpp}
TestClass test;
test.test_pos();
\end{cpp}

Modified code


\begin{center}
Figure 7.2: Code transformations for TestClass's method calls
\end{center}

The tool should also ignore all public methods with the required modifications already applied, either manually or automatically. In other words, if a method already has the required 'test\_' prefix, the tool should not modify it.

We are going to create a Clang tool called 'methodrename', which will perform all the required code modifications. This tool will utilize the recursive AST visitor discussed in Section 3.4, Recursive AST visitor. The most crucial aspect is the implementation of the Visitor class. Let's examine it in detail.

\mySubsubsection{7.2.3.}{Visitor class implementation}

Our Visitor class should handle specific processing for the following AST nodes:

clang::CXXRecordDecl: This involves processing C++ class definitions with names starting with the "Test" prefix. For such classes, all user-defined public methods should be prefixed with "test\_".

clang::CXXMemberCallExpr: Additionally, we need to identify all instances where the modified method is used and make the corresponding changes following the method's renaming in the class definition.

The processing for clang::CXXRecordDecl nodes will be as follows:

\begin{cpp}
bool VisitCXXRecordDecl(clang::CXXRecordDecl *Class) {
  if (!Class->isClass())
    return true;
  if (!Class->isThisDeclarationADefinition())
    return true;
  if (!Class->getName().starts_with("Test"))
    return true;
  for (const clang::CXXMethodDecl *Method : Class->methods()) {
    clang::SourceLocation StartLoc = Method->getLocation();
    if (!processMethod(Method, StartLoc, "Renamed method"))
      return false;
  }
  return true;
}
\end{cpp}

\begin{center}
Figure 7.3: CXXRecordDecl visitor implementation
\end{center}

Lines 11-16 in Figure 7.3 represent the conditions that we require from the examined node. For example, the corresponding class name should start with the "Test" prefix (see Lines 15-16 in Figure 7.3), where we utilize the starts\_with() method of the llvm::StringRef class.

After verifying these conditions, we proceed to examine the methods within the found class.

The verification process is implemented in the Visitor::processMethod method, and its implementation is presented in the following code fragment:

\begin{cpp}
bool processMethod(const clang::CXXMethodDecl *Method,
                   clang::SourceLocation StartLoc, const char *LogMessage) {
  if (Method->getAccess() != clang::AS_public)
    return true;
  if (llvm::isa<clang::CXXConstructorDecl>(Method))
    return true;
  if (!Method->getIdentifier() || Method->getName().starts_with("test_"))
    return true;

  std::string OldMethodName = Method->getNameAsString();
  std::string NewMethodName = "test_" + OldMethodName;
  clang::SourceManager &SM = Context.getSourceManager();
  clang::tooling::Replacement Replace(SM, StartLoc, OldMethodName.length(),
                                      NewMethodName);
  Replaces.push_back(Replace);
  llvm::outs() << LogMessage << ": " << OldMethodName << " to "
               << NewMethodName << "\n";
  return true;
}
\end{cpp}

\begin{center}
Figure 7.4: Implementation of processMethod
\end{center}

Lines 46-51 in Figure 7.4 contain the checks for the required conditions. For instance, in Lines 46-47, we verify that the method is public. Lines 48-49 are used to exclude constructors from processing, and Lines 50-51 serve to exclude methods that already have the required prefix.

The main replacement logic is implemented in Lines 53-58. Particularly, in Lines 56-57, we create a special clang::tooling::Replacement object, which serves as a wrapper for required code modifications. The object's parameters are as follows:

\begin{enumerate}
\item
clang::SourceManager: We obtain the source manager from clang::ASTContext at Line 55.

\item
clang::SourceLocation: The source location specifies the starting position for replacement. The position is passed as the second parameter of our processMethod method, as seen in Line 45.

\item
unsigned: The length of the replaced text.

\item
clang::StringRef: The replacement text, which we create at Line 54.
\end{enumerate}

We store the replacement in the Replaces object, a private member of our Visitor class:

\begin{cpp}
40 private:

41   clang::ASTContext &Context;


42   std::vector<clang::tooling::Replacement> Replaces;
There is a special getter to access the object outside the Visitor class:

36   const std::vector<clang::tooling::Replacement> &getReplacements() {


37     return Replaces;

38   }
\end{cpp}

We log the action at Lines 59-60, using LogMessage as the prefix for the log message. Different log messages are used for different AST nodes; for instance, we use "Renamed method" (see Figure 7.3, Line 19) for clang::CXXRecordDecl.

The log message will be different for the method call. The corresponding processing is shown in the following figure.

\begin{cpp}
bool VisitCXXMemberCallExpr(clang::CXXMemberCallExpr *Call) {
  if (clang::CXXMethodDecl *Method = Call->getMethodDecl()) {
    clang::CXXRecordDecl *Class = Method->getParent();
    if (!Class->getName().starts_with("Test"))
      return true;
    clang::SourceLocation StartLoc = Call->getExprLoc();
    return processMethod(Method, StartLoc, "Renamed method call");
   }
   return true;
}
\end{cpp}

\begin{center}
Figure 7.5: CXXMemberCallExpr visitor implementation
\end{center}

We verify that the class name, which holds the test method, starts with the 'Test' prefix at Lines 27-29. The replacement source location is obtained at Line 30. At Line 31, we call our processMethod function to process the found method, passing the "Renamed method call" as the log message to the call.

The Visitor is initialized in the Consumer class, which will be our next goal.

\mySubsubsection{7.2.4.}{Consumer class implementation}

The Consumer class initializes the Visitor and starts AST traversal in the HandleTranslationUnit method. The class can be written as follows:

\begin{cpp}
class Consumer : public clang::ASTConsumer {
public:
  void HandleTranslationUnit(clang::ASTContext &Context) override {
    Visitor V(Context);
    V.TraverseDecl(Context.getTranslationUnitDecl());

    // Apply the replacements.
    clang::Rewriter Rewrite(Context.getSourceManager(), clang::LangOptions());
    auto &Replaces = V.getReplacements();
    for (const auto &Replace : Replaces) {
      if (Replace.isApplicable()) {
        Replace.apply(Rewrite);
      }
    }

    // Apply the Rewriter changes.
    if (Rewrite.overwriteChangedFiles()) {
      llvm::errs() << "Error: Cannot apply changes to the file\n";
    }
  }
};
} // namespace methodrename
\end{cpp}

\begin{center}
Figure 7.6: Consumer class implementation
\end{center}

We initialize the Visitor and begin traversal at Lines 9-10 (see Figure 7.6). The Rewriter is created at Line 13, and replacements are applied at Lines 14-19. Finally, the result is stored in the original file at Lines 22-24.

The Visitor and Consumer classes are wrapped within the clangbook::methodrename namespace. The Consumer instance is created in the FrontendAction class. This class's implementation mirrors that of the RecursiveVisitor and DeclVisitor, as detailed in Figure 3.8. The only difference is the use of the clangbook::methodrename namespace for the new tool.

\mySubsubsection{7.2.5.}{Build configuration and main function}

The main function for our tool is similar to the recursive visitor one defined in Figure 3.21:

\begin{cpp}
int main(int argc, const char **argv) {
  llvm::Expected<clang::tooling::CommonOptionsParser> OptionsParser =
    clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory);
  if (!OptionsParser) {
    llvm::errs() << OptionsParser.takeError();
    return 1;
  }
  clang::tooling::ClangTool Tool(OptionsParser->getCompilations(),
                                 OptionsParser->getSourcePathList());
   return Tool.run(clang::tooling::newFrontendActionFactory<
                   clangbook::methodrename::FrontendAction>()
                   .get());
}
\end{cpp}

\begin{center}
Figure 7.7: The main function for the 'methodrename' test tool
\end{center}

As you can see, we changed only the namespace name for our custom frontend action at Line 23.

The build configuration is specified as follows:

\begin{cmake}
cmake_minimum_required(VERSION 3.16)
project("methodrename")

if ( NOT DEFINED ENV{LLVM_HOME})
  message(FATAL_ERROR "$LLVM_HOME is not defined")
else()
  message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}")
  set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation")
  set(LLVM_LIB ${LLVM_HOME}/lib)
  set(LLVM_DIR ${LLVM_LIB}/cmake/llvm)
  find_package(LLVM REQUIRED CONFIG)
  include_directories(${LLVM_INCLUDE_DIRS})
  link_directories(${LLVM_LIBRARY_DIRS})
  set(SOURCE_FILE MethodRename.cpp)
  add_executable(methodrename ${SOURCE_FILE})
  set_target_properties(methodrename PROPERTIES COMPILE_FLAGS "-fno-rtti")
  target_link_libraries(methodrename
    LLVMSupport
    clangAST
    clangBasic
    clangFrontend
    clangSerialization
    clangToolingCore
    clangRewrite
    clangTooling
  )
endif()
\end{cmake}

\begin{center}
Figure 7.8: Build configuration for 'methodrename' test tool
\end{center}

The most notable changes, compared to the code from Figure 3.20, are at Lines 23 and 24, where we added two new libraries to support code modifications: clangToolingCore and clangRewrite . Other changes include the new name for the tool (Line 2) and the source file that contains the main function (Line 14).

As soon as we finish with the code, it's time to build and run our tool.

7.2.6 Running the code modification tool
The program can be compiled using the same sequence of commands as we used previously in Section 3.3, AST traversal, see Figure 3.11:

\begin{shell}
export LLVM_HOME=<...>/llvm-project/install
mkdir build
cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ...
ninja
\end{shell}

\begin{center}
Figure 7.9: Configure and build commands for 'methodrename' tool
\end{center}

We can run the create tool on the following test file (TestClass.cpp ):

\begin{cpp}
class TestClass {
public:
  TestClass(){};
  void pos(){};
};

int main() {
  TestClass test;
  test.pos();
  return 0;
}
\end{cpp}


\begin{center}
Figure 7.10: Original TestClass.cpp
\end{center}

We can run the tool as follows:

\begin{shell}
$ ./methodrename TestClass.cpp -- -std=c++17
Renamed method: pos to test_pos
Renamed method call: pos to test_pos
\end{shell}


\begin{center}
Figure 7.11: Running methodrename Clang Tool on TestClass.cpp
\end{center}

As we can see, the method TestClass::pos was renamed to TestClass::test\_pos. The method call was also updated, as shown in the following figure:

\begin{cpp}
class TestClass {
public:
  TestClass(){};
  void test_pos(){};
};

int main() {
  TestClass test;
  test.test_pos();
  return 0;
}
\end{cpp}

\begin{center}
Figure 7.12: Modified TestClass.cpp
\end{center}

The provided example demonstrates how Clang can assist in creating refactoring tools. The created Clang Tool uses a recursive visitor to set up the required code transformation. Another possible option is to use Clang-Tidy, which we investigated earlier in Chapter 5, Clang-Tidy Linter Framework. Let's examine this option in more detail.




















































