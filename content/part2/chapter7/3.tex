We plan to investigate FixItHint, which is a part of the Clang Diagnostics subsystem (see Section 4.4.2, Diagnostics support). FixItHint can be integrated with clang::Rewriter and clang::tooling::Replacement explored previously, providing advanced diagnostics that are used in powerful tools such as Clang-Tidy.


\mySubsubsection{7.3.1.}{FixItHint}

clang::FixItHint is a class in the Clang compiler that significantly enhances its diagnostic capabilities. Its primary role is to provide automated suggestions for correcting code errors or issues that the compiler detects. These suggestions, known as ”fix-its,” are a part of Clang’s diagnostic messages and are intended to guide developers in resolving identified issues in their code.

When Clang encounters a coding error, warning, or stylistic issue, it generates a FixItHint. This hint contains specific recommendations for changes in the source code. For instance, it may suggest replacing a snippet of text with a corrected version or inserting or removing code at a particular location.

For example, consider the following source code:

\begin{cpp}
void foo() {
  constexpr int a = 0;
  constexpr const int *b = &a;
}
\end{cpp}

\begin{center}
Figure 7.13: Test file foo.cpp
\end{center}

If we run a compilation for the file, we will get the following error:

\begin{shell}
$ <...>/llvm-project/install/bin/clang -cc1 -emit-obj foo.cpp -o /tmp/foo.o
foo.cpp:3:24: error: constexpr variable ’b’ must be initialized by a
constant expression
    3 |   constexpr const int *b = &a;
      |                        ^   ~~
foo.cpp:3:24: note: pointer to ’a’ is not a constant expression
foo.cpp:2:17: note: address of non-static constexpr variable ’a’ may differ
on each invocation of the enclosing function; add ’static’ to give it a
constant address
    2 |   constexpr int a = 0;
      |                 ^
      |   static
1  error generated.
\end{shell}

\begin{center}
Figure 7.14: Compilation error generated in foo.cpp
\end{center}

As you can see, the compiler suggests adding the static keyword at Line 2 for the program shown in Figure 7.13.

The error is processed by Clang using the FixItHint object, as shown in Figure 7.15. As seen in Figure 7.15, when Clang detects an issue in the source code and generates a diagnostic, it can also produce a clang::FixItHint that suggests how to fix the issue. The hint is later processed by the Clang diagnostics subsystem and displayed to the user.

It’s important to highlight that the hint can also be converted into a Replacement object, which represents the exact text change needed. For example, Clang-Tidy uses the Replacement object as temporary storage for information from FixItHint in its DiagnosticConsumer class implementation, allowing the FixItHint to be converted into a Replacement object that represents the exact text change needed.

\begin{cpp}
if (VarD && VarD->isConstexpr()) {
  // Non-static local constexpr variables have unintuitive semantics:
  //   constexpr int a = 1;
  //   constexpr const int *p = &a;
  // ... is invalid because the address of ’a’ is not constant. Suggest
  // adding a ’static’ in this case.
  Info.Note(VarD->getLocation(), diag::note_constexpr_not_static)
    << VarD
    << FixItHint::CreateInsertion(VarD->getBeginLoc(), "static ");
\end{cpp}

\begin{center}
Figure 7.15: Code fragment from clang/lib/AST/ExprConstant.cpp
\end{center}

Overall, clang::FixItHint enhances the user-friendliness and utility of Clang, providing developers with practical tools for improving code quality and resolving issues efficiently. Its integration into Clang’s diagnostic system exemplifies the compiler’s emphasis on not only pinpointing code issues but also aiding in their resolution. We are going to utilize this feature in a Clang-Tidy check that will rename methods in a test class and convert the code shown in Figure 7.10 to that in Figure 7.12.

\mySubsubsection{7.3.2.}{Creating project skeleton}

Let’s create the project skeleton for our Clang-Tidy check. We will name our check ”methodrename” and it will be a part of ”misc” set of Clang-Tidy checks. We will use the command from Section 5.4.1

\begin{shell}
$ ./clang-tools-extra/clang-tidy/add_new_check.py misc methodrename
\end{shell}

Figure 7.16: Creating a skeleton for the misc-methodrename check

The command from Figure 7.16 should be run from the root of the cloned LLVM project. We specified two parameters for the add\_new\_check.py script: misc – the set of checks that will contain our new check, and methodrename – the name of our check.

The command will produce the following output:

\begin{shell}
Updating ./clang-tools-extra/clang-tidy/misc/CMakeLists.txt...
Creating ./clang-tools-extra/clang-tidy/misc/MethodrenameCheck.h...
Creating ./clang-tools-extra/clang-tidy/misc/MethodrenameCheck.cpp...
Updating ./clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp...
Updating clang-tools-extra/docs/ReleaseNotes.rst...
Creating clang-tools-extra/test/clang-tidy/checkers/misc/methodrename.cpp...
Creating clang-tools-extra/docs/clang-tidy/checks/misc/methodrename.rst...
Updating clang-tools-extra/docs/clang-tidy/checks/list.rst...
Done. Now it’s your turn!
\end{shell}

\begin{center}
Figure 7.17: Artefacts created for misc-methodrename check
\end{center}


We have to modify at least two generated files in the ./clang-tools-extra/clang-tidy /misc folder:

\begin{enumerate}
\item
MethodrenameCheck.h : This is the header file for our check. Here, we want to add an additional private method processMethod for checking the method’s properties and displaying diagnostics.

\item
MethodrenameCheck.cpp : This file contains the processing logic, and we need to implement three methods: registerMatchers, check, and the newly added private method processMethod.
\end{enumerate}

\mySubsubsection{7.3.3.}{Check implementation}

We will start with modifications to the header file:

\begin{cpp}
private:
  void processMethod(const clang::CXXMethodDecl *Method,
                     clang::SourceLocation StartLoc, const char *LogMessage);
};
\end{cpp}

\begin{center}
Figure 7.18: MethodrenameCheck.h modifications
\end{center}


The added private method MethodrenameCheck::processMethod has the same parameters as the method introduced earlier in our Clang Tool ’methodrename’, as seen in Figure 7.4.

We start the implementation with the MethodrenameCheck::registerMatchers method of our check as follows:

\begin{cpp}
void MethodrenameCheck::registerMatchers(MatchFinder *Finder) {
  auto ClassMatcher = hasAncestor(cxxRecordDecl(matchesName("::Test.*$")));
  auto MethodMatcher = cxxMethodDecl(isNotTestMethod(), ClassMatcher);
  auto CallMatcher = cxxMemberCallExpr(callee(MethodMatcher));
  Finder->addMatcher(MethodMatcher.bind("method"), this);
  Finder->addMatcher(CallMatcher.bind("call"), this);
}
\end{cpp}

\begin{center}
Figure 7.19: Implementation of registerMatchers
\end{center}

Lines 30 and 31 register two matchers. The first one is for method declarations (bound to the ”method” identifier), and the second one is for method calls (bound to the ”call” identifier).

Here, we use a Domain Specific Language (DSL) defined in Section 3.5, AST matchers. The ClassMatcher specifies that our method declaration has to be declared within a class with a name starting with the ”Test” prefix.

The method declaration matcher (MethodMatcher) is defined at Line 28. It must be declared within the class specified by ClassMatcher and should be a test method (details about the isNotTestMethod matcher will be described below).

The last matcher, CallMatcher, is defined at Line 29 and specifies that it must be a call to a method that satisfies the conditions of MethodMatcher.

The isNotTestMethod matcher is an ad-hoc matcher that is used to check our specific conditions. We can define our own matchers using AST\_MATCHER and related macros. The implementation for it can be found here:

\begin{cpp}
AST_MATCHER(CXXMethodDecl, isNotTestMethod) {
  if (Node.getAccess() != clang::AS_public) return false;
  if (llvm::isa<clang::CXXConstructorDecl>(&Node)) return false;
  if (!Node.getIdentifier() || Node.getName().startswith("test_")) return false;
  return true;
}
\end{cpp}

\begin{center}
Figure 7.20: isNotTestMethod matcher implementation
\end{center}

The macro has two parameters. The first one specifies the AST node we want to check, which is clang::CXXMethodDecl in our case. The second parameter is the matcher name that we want to use for the user-defined matcher, which is isNotTestMethod in our case.

The AST node can be accessed as a Node variable at the macro body. The macro should return true if the Node matches the required conditions. We use the same conditions we used for our ’methodrename’ Clang Tool in Figure 7.4 (Lines 46-51).

The MethodrenameCheck::check is the main method for our check and can be implemented as follows:

\begin{cpp}
void MethodrenameCheck::check(const MatchFinder::MatchResult &Result) {
  if (const auto *Method = Result.Nodes.getNodeAs<CXXMethodDecl>("method")) {
    processMethod(Method, Method->getLocation(), "Method");
  }

  if (const auto *Call = Result.Nodes.getNodeAs<CXXMemberCallExpr>("call")) {
    if (CXXMethodDecl *Method = Call->getMethodDecl()) {
      processMethod(Method, Call->getExprLoc(), "Method call");
    }
  }
}
\end{cpp}

\begin{center}
Figure 7.21: check implementation
\end{center}

The code has two blocks. The first one (Lines 35-37) processes method declarations, and the last one (Lines 39-42) processes method calls. Both call MethodrenameCheck ::processMethod to display diagnostics and create the required code modifications.

Let’s examine how it’s implemented and how clang::FixItHint is used.

\begin{cpp}
void MethodrenameCheck::processMethod(const clang::CXXMethodDecl *Method,
                                      clang::SourceLocation StartLoc,
                                      const char *LogMessage) {
  diag(StartLoc, "%0 %1 does not have ’test_’ prefix") << LogMessage << Method;
  diag(StartLoc, "insert ’test_’", DiagnosticIDs::Note)
    << FixItHint::CreateInsertion(StartLoc, "test_");
}
\end{cpp}

\begin{center}
Figure 7.22: processMethod implementation
\end{center}

We print diagnostics about the detected issue at Line 49. Lines 50-51 print an informational message about the suggested code modifications and create the corresponding code replacement at Line 51. To insert text, we use clang::FixItHint::CreateInsertion. We also display the insertion as a note for our primary warning.

As soon as all the required changes are applied to the generated skeleton, it’s time to build and run our check on a test file.

\mySubsubsection{7.3.4.}{Build and run the check}

We assume that build configuration from Figure 1.12 was used. Thus, we have to run the following command to build our check:

\begin{shell}
$ ninja clang-tidy
\end{shell}

We can install it to the install folder with:

\begin{shell}
$ ninja install
\end{shell}

We can run our check as follows on the TestClass from Figure 7.10:

\begin{shell}
$ <...>/llvm-project/install/bin/clang-tidy \
             -checks=’-*,misc-methodrename’ \
               ./TestClass.cpp              \
             -- -std=c++17
\end{shell}


\begin{center}
Figure 7.23: Clang-Tidy misc-methodrename check run on the test file TestClass.cpp
\end{center}

The command will produce the following output:

\begin{shell}
TestClass.cpp:4:8: warning: Method ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  void pos(){};
       ^
TestClass.cpp:4:8: note: insert ’test_’
  void pos(){};
       ^
       test_
TestClass.cpp:9:8: warning: Method call ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  test.pos();
       ^
TestClass.cpp:9:8: note: insert ’test_’
  test.pos();
       ^
       test_
\end{shell}

\begin{center}
Figure 7.24: Warning generated for TestClass.cpp by misc-methodrename check
\end{center}


As we can see, the check correctly detected two places where the method name has to be changed and created replacements. The command from Figure 7.23 does not modify the original source file. We have to specify an additional argument -fix-notes to apply the insertions specified as notes to the original warnings. The required command will look like this:

\begin{shell}
$ <...>/llvm-project/install/bin/clang-tidy \
               -fix-notes                   \
               -checks=’-*,misc-methodrename’ \
               ./TestClass.cpp              \
               -- -std=c++17
\end{shell}


\begin{center}
Figure 7.25: Clang-Tidy with -fix-notes option
\end{center}

The command output is as follows:

\begin{shell}
2 warnings generated.
TestClass.cpp:4:8: warning: Method ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  void pos(){};
       ^
TestClassSmall.cpp:4:8: note: FIX-IT applied suggested code changes
TestClass.cpp:4:8: note: insert ’test_’
  void pos(){};
       ^
       test_
TestClass.cpp:9:8: warning: Method call ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  test.pos();
       ^
TestClass.cpp:9:8: note: FIX-IT applied suggested code changes
TestClass.cpp:9:8: note: insert ’test_’
  test.pos();
       ^
       test_
clang-tidy applied 2 of 2 suggested fixes.
\end{shell}


\begin{center}
Figure 7.26: Clang-Tidy fixes applied to the TestClass.cpp
\end{center}

As we can see, the required insertions were applied here. Clang-Tidy has powerful tools to control the applied fixes and can be considered a significant resource for code modification. Another popular tool used for code modification is Clang-Format. As the name suggests, this tool specializes in code formatting. Let’s explore it in detail.



























































































