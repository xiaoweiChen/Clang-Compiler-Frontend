Precompiled headers PCH, are a Clang feature designed to improve Clang's frontend performance. The basic idea is to create an AST (Abstract Syntax Tree) for a header file and reuse this AST during compilation for sources that include the header file.

Generating a precompiled header file is simple [5]. Suppose you have the following header file, header.h :

\begin{cpp}
#pragma once

void foo() {
}
\end{cpp}

\begin{center}
Figure 10.1: Header file to be compiled to PCH
\end{center}

You can generate a PCH for it with the following command:

\begin{shell}
$ <...>/llvm-project/install/bin/clang -cc1 -emit-pch        \
                                      -x c++-header header.h \
                                      -o header.pch
\end{shell}

Here, we use the -x c++-header option to specify that the header file should be treated as a C++ header file. The output file will be named header.pch .

Simply generating precompiled headers is not enough; you need to start using them. A typical C++ source file that includes the header may look like this:

\begin{cpp}
#include "header.h"

int main() {
  foo();
  return 0;
}
\end{cpp}

\begin{center}
Figure 10.2: Source file that includes header.h
\end{center}

As you can see, the header is included as follows:

\begin{cpp}
#include "header.h"
\end{cpp}

\begin{center}
Figure 10.3: Header header.h inclusion
\end{center}

By default, Clang will not use a PCH, and you have to specify it explicitly with the following command:

\begin{shell}
$ <...>/llvm-project/install/bin/clang -cc1 -emit-obj        \
                                     -include-pch header.pch \
                                     main.cpp -o main.o
\end{shell}

Here, we use -include-pch to specify the included precompiled header: header.pch .

You can check this command with a debugger, and it will give you the following output:

\begin{shell}
$ lldb <...>/llvm-project/install/bin/clang -- -cc1 -emit-obj -include-pch header.pch main.cpp -o main.o
 ...
 (lldb) b clang::ASTReader::ReadAST
 ...
 (lldb) r
 ...
 -> 4431   llvm::TimeTraceScope scope("ReadAST", FileName);
    4432
    4433   llvm::SaveAndRestore SetCurImportLocRAII(CurrentImportLoc, ImportLoc);
    4434   llvm::SaveAndRestore<std::optional<ModuleKind>> SetCurModuleKindRAII(
 (lldb) p FileName
 (llvm::StringRef)  (Data = "header.pch", Length = 10)
\end{shell}

\begin{center}
Figure 10.4: Loading precompiled header at clang::ASTReader::ReadAST
\end{center}

From this example, you can see that Clang reads the AST from the precompiled header file. It's important to note that the precompiled header is read before parsing, allowing Clang to obtain all symbols from the header file before parsing the main source file. This makes explicit header inclusion unnecessary. Therefore, you can remove the \#include "header.h" directive from the source file and achieve successful compilation.

This is impossible without precompiled headers, where you would encounter the following compilation error:

\begin{shell}
main.cpp:4:3: error: use of undeclared identifier 'foo'
   4 |   foo();
     |   ^
1  error generated.
\end{shell}

\begin{center}
Figure 10.5: Compilation error generated due to missing includes
\end{center}

It's worth noting that only the first -{}-include-pch option will be processed; all others will be ignored. This reflects the fact that there can be only one precompiled header for a translation unit. On the other hand, a precompiled header can include another precompiled header. This functionality is known as chained precompiled headers [3], as it creates a chain of dependencies where one precompiled header depends on another precompiled header.

The usage of precompiled headers is not limited to regular compilation. As we saw in Figure 8.38, AST build at Clangd, precompiled headers are actively used for performance optimizations in Clangd as placeholders for a cache for the preamble that contains included headers.

Precompiled headers are a technique that has been used for a long time, but they have some limitations. One of the most important limitations is that there can be only one precompiled header, which significantly limits the usage of PCH in real projects. Modules address some of the problems related to precompiled header. Lets explore them.
